<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>fcntl 锁在 Go 中通过 execve 之后不生效的问题 | Sakeven&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
  <h1>
    <span class="title">fcntl 锁在 Go 中通过 execve 之后不生效的问题</span>
  </h1>
   
  
  
  <h2 class="date">2018/05/10</h2>
  
  

  <p class="terms">
      Categories: 
    <a href="/categories/os">OS</a> 
    <a href="/categories/linux">Linux</a>     Tags: 
    <a href="/tags/linux">linux</a> 
    <a href="/tags/fcntl">fcntl</a> 
    <a href="/tags/lock">lock</a>   
  </p>
</div>

<main>
  

<h1 id="背景">背景</h1>

<p>man 2 fcntl</p>

<blockquote>
<p>Record locks are not inherited by a child created via <strong>fork</strong>(2), but are preserved across an <strong>execve</strong>(2).</p>
</blockquote>

<p>看到 fcntl 的介绍，我们想当然地认为 fcntl 的记录锁在 execve 之后都是能够保留的。</p>

<p>在我们使用 Go 来实现的时候，很快就发现了问题，请看如下代码：</p>

<pre><code class="language-c">package main

import (
   &quot;fmt&quot;
   &quot;log&quot;
   &quot;os&quot;
   &quot;runtime&quot;
   &quot;syscall&quot;
   &quot;time&quot;
)

func main() {
   fmt.Println(&quot;Begin&quot;)
   fd, err := syscall.Open(&quot;lock&quot;, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0777)
   if err != nil {
       log.Printf(&quot;%s&quot;, err)
       return
   }

   ft := &amp;syscall.Flock_t{
       Type: syscall.F_WRLCK,
   }

   err = syscall.FcntlFlock(uintptr(fd), syscall.F_SETLK, ft)
   if err != nil {
       log.Printf(&quot;%s&quot;, err)
       return
   }

   fmt.Printf(&quot;Pid %d  fd %d \n&quot;, os.Getpid(), fd)
   time.Sleep(5 * time.Second)

   argv := []string{&quot;./test.sh&quot;}
   syscall.Exec(argv[0], argv, []string{})
}
</code></pre>

<p>这段代码在 Linux 上，是无法把 fcntl 的锁传递给 test.sh 进程的。然而在 macOS 上很正常。</p>

<p>另外通过 C/Python 来实现，也是没有问题的。</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;

int main() {
    printf(&quot;begin %d\n&quot;, getpid());
    int fd = open(&quot;lock&quot;, O_WRONLY | O_CREAT | O_TRUNC , 0777);
    if (fd &lt; 0 ) {
      printf(&quot;fail to open&quot;);
      return -1;
    }

    printf(&quot;fd %d\n&quot;, fd); 

    struct flock fl ;
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = 0;
    
    int errno = fcntl(fd, F_SETLK, &amp;fl);
    if( errno != 0) {
      printf(&quot;err %d&quot;, errno);
      return -1;
    }

    sleep(5);
    char *env[] = { NULL };
    char *argv[] = {&quot;./test.sh&quot;, NULL};
    execve(argv[0], argv, env);
    return 0;
}
</code></pre>

<p>所以问题是出在 Go 语言本身吗？</p>

<h1 id="原因">原因</h1>

<p>在同事手写了一个内核模块深入分析后，发现内核在 exceve 时关闭了锁。阅读 Linux Kernel 源码后，终于发现真相。</p>

<p>我们来看下 exceve 系统调用的部分实现。</p>

<p><a href="https://elixir.bootlin.com/linux/latest/source/fs/exec.c#L1724">do_execveat_common</a> 中：</p>

<pre><code class="language-c">struct files_struct *displaced;
retval = unshare_files(&amp;displaced);
...
if (displaced)
    put_files_struct(displaced);
</code></pre>

<p>我们需要关注的是 displaced 这个变量。</p>

<p>unshare_files 调用了 unshare_fd:</p>

<pre><code class="language-c">/*
 *    Helper to unshare the files of the current task.
 *    We don't want to expose copy_files internals to
 *    the exec layer of the kernel.
 */

int unshare_files(struct files_struct **displaced)
{
    struct task_struct *task = current;
    struct files_struct *copy = NULL;
    int error;

    error = unshare_fd(CLONE_FILES, &amp;copy);
    if (error || !copy) {
        *displaced = NULL;
        return error;
    }
    *displaced = task-&gt;files;
    task_lock(task);
    task-&gt;files = copy;
    task_unlock(task);
    return 0;
}
</code></pre>

<p>unshare_fd:</p>

<pre><code class="language-c">/*
 * Unshare file descriptor table if it is being shared
 */
static int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)
{
    struct files_struct *fd = current-&gt;files;
    int error = 0;

    if ((unshare_flags &amp; CLONE_FILES) &amp;&amp;
        (fd &amp;&amp; atomic_read(&amp;fd-&gt;count) &gt; 1)) {
        *new_fdp = dup_fd(fd, &amp;error);
        if (!*new_fdp)
            return error;
    }

    return 0;
}
</code></pre>

<p>这里，当发现 fd 的引用计数大于 1 时，调用 dup_fd 复制一个新的 fdt 表。</p>

<p>之后在 put_files_struct 函数中 displaced 文件进行关闭操作。</p>

<pre><code class="language-c">void put_files_struct(struct files_struct *files)
{
    if (atomic_dec_and_test(&amp;files-&gt;count)) {
        struct fdtable *fdt = close_files(files);

        /* free the arrays if they are not embedded */
        if (fdt != &amp;files-&gt;fdtab)
            __free_fdtable(fdt);
        kmem_cache_free(files_cachep, files);
    }
}
</code></pre>

<h1 id="结论">结论</h1>

<p>所以在单线程环境中，fd 的引用计数等于 1，原来的 fdt 会被之后的进程继承。而在多线程环境下，旧的 fdt 会被替换并且关闭。</p>

<p>总之，多线程环境下，慎用 fcntl 记录锁。</p>

<p>当我们在 C 代码中加入线程后，就能发现 execve 之后 fcntl 锁没有保留。</p>

<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;  
#include &lt;stdlib.h&gt;

void thread(){   
    for(int i=0;i&lt;=5;i++)  
    {  
        printf(&quot;this is thread %d\n&quot;, i);  
        sleep(5);
    }  
}  

int main() {
    printf(&quot;begin %d\n&quot;, getpid());
    int fd = open(&quot;lock&quot;, O_WRONLY | O_CREAT | O_TRUNC , 0777);
    if (fd &lt; 0 ) {
        printf(&quot;fail to open&quot;);
        return -1;
    }

    printf(&quot;fd %d\n&quot;, fd); 

    struct flock fl ;
    fl.l_type = F_WRLCK;
    fl.l_whence = SEEK_SET;
    fl.l_start = 0;
    fl.l_len = 0;
    
    int errno = fcntl(fd, F_SETLK, &amp;fl);
    if( errno != 0) {
        printf(&quot;err %d&quot;, errno);
        return -1;
    }

    pthread_t id;  //线程的标识符,unsigned long int.  
    int ret,i=0;  
    ret = pthread_create(&amp;id,NULL,(void *)thread,NULL);   
    if(ret!=0)    //  线程创建成功返回0  
    {  
        printf(&quot;To thread failed\n&quot;);  
        exit(0);  
    }  

    sleep(5);
    char *env[] = { NULL };
    char *argv[] = {&quot;./test.sh&quot;, NULL};
    execve(argv[0], argv, env);
    return 0;
}
</code></pre>

</main>

  <footer>
  <script>
(function() {
    var i, text, code, codes = document.getElementsByTagName('code');
    for (i = 0; i < codes.length;) {
      code = codes[i];
      if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
        text = code.textContent;
        if (/^\$[^$]/.test(text) && /[^$]\$$/.test(text)) {
          text = text.replace(/^\$/, '\\(').replace(/\$$/, '\\)');
          code.textContent = text;
        }
        if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
            /^\$(.|\s)+\$$/.test(text) ||
            /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
          code.outerHTML = code.innerHTML;  
          continue;
        }
      }
      i++;
    }
  })();  
</script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>
  
  <hr/>
  &copy; <a href="mailto:sakeven.jiang@gmail.com">Sakven Jiang</a> 2017-2019 | <a href="https://github.com/sakeven">GitHub</a>
  
  </footer>
  </body>
</html>

