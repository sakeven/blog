<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>素数 | Sakeven&#39;s Blog</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/categories/">Categories</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">素数</span></h1>

<h2 class="date">2013/10/24</h2>

<p class="terms">
  
  
  Categories: <a href="/categories/algorithm">Algorithm</a> 
  
  
  
  Tags: <a href="/tags/acm">acm</a> <a href="/tags/number-theory">number theory</a> 
  
  
</p>
</div>

<main>


<h2 id="〇-素数的性质">〇. 素数的性质</h2>

<p>素数只能被 1 和它本身整除。</p>

<h2 id="一-素数的普通算法">一. 素数的普通算法</h2>

<p>最朴素的素数测试，试除法，依次检验 \( 1-\sqrt n \) 能否整除 n</p>

<pre><code class="language-c++">bool is_prime(int n)
{
	if(n % 2== 0 &amp;&amp; n != 2)
		return false;
	for(int i = 3; i * i &lt; n; i += 2)
		if(n % i == 0)
			return false;
	return true;
}
</code></pre>

<h2 id="二-普通筛选法">二. 普通筛选法</h2>

<p>当 n 为素数时，is_prime[n] = 0;
依次排除 2 的倍数，3 的倍数，5 的倍数&hellip;</p>

<pre><code class="language-c++">bool is_prime[1000];
int check_prime()
{
    memset(is_prime,0,sizeof(is_prime));
    for(int i = 2; i &lt; 1000; i ++)
    {
        if(is_prime[i] == 0)
        {
            for(int j = 2*i; j &lt; 1000;j += i)
                is_prime[j] = 1;
        }
    }
}
</code></pre>

<h2 id="三-除余法">三. 除余法</h2>

<p>由普通的素数测试演化而来，当我们对 2 到 n 的数字进行测试时，发现 2 的倍数会被测试，同理，3 的倍数也会被测试。
于是我们就想能否将 2 的倍数、3 的倍数排除掉
这里我们令 \( n_1 = 6*k+1 \)、\( n_2=6*k+2 \)、\( n_3=6*k+3 \)、\( n_4=6*k+4 \)、\(n_5=6*k+5\)、\(n_6=6*k+6 \) &hellip;</p>

<p>此时我们发现只需测试 \( n_1 \)、\(n_5\)、\(n_7\)、\(n_{11}\) &hellip;这样我们只需测试  <sup>2</sup>&frasl;<sub>6</sub>=<sup>1</sup>&frasl;<sub>3</sub> ；</p>

<p>根据此规律不难发现其规则为 4，2，4，2 的间隔</p>

<pre><code class="language-c++">int creat_prime(int p[], int n, int total)  
{  
    int i, j, g = 2;  
    for (i = 7; i &lt;= n; i += g) {  
        g = 6 - g;  
        for (j = 0; p[j] * p[j] &lt;= i &amp;&amp; i % p[j]; j++);  
        if (i % p[j]) {  
            p[total++] = i;  
        }  
    }  
    return total;  
}
</code></pre>

<h2 id="四-miller-rabin-素性测试">四. Miller-Rabin 素性测试</h2>

<p>素性测试是对一个正整数是否为素数的测试。</p>

<p>由于是随机测试，素数一定可以通过的测试，而合数不一定不能通过测试。所以我们往往取 3 次测试，提高测试的准确性。</p>

<h3 id="费马小定里">费马小定里</h3>

<blockquote>
<p>若 n 是一个素数，且 a 与 n 互质, 那么 \(a^{n-1} \equiv 1 (mod\ n) \)</p>
</blockquote>

<p>费马小定理只是个必要条件, 符合费马小定理而非素数的数叫做 Carmichael。前 3 个 Carmichael 数是 561, 1105, 1729。Carmichael 数是非常少的。 在 1~100000000 范围内的整数中，只有 255 个 Carmichael 数。</p>

<p>为此又有二次探测定理,以确保该数为素数.</p>

<h3 id="二次探测定理">二次探测定理</h3>

<blockquote>
<p>如果 p 是一个素数，\(0&lt;x&lt;p\)，则方程 \(x^2 \equiv 1(mod\ p)\) 的解为 \(x=1, x=p-1\)</p>
</blockquote>

<p>根据以上两个定理，得到 Miller-Rabin 算法的一般步骤：</p>

<ol>
<li>先计算出 m、j，使得 \(n-1=m*2^j\)，其中 m 是正奇数，j 是非负整数</li>
<li>随机取一个 b，\(b \ge 2 \)</li>
<li>计算 \( v=b^m mod\ n \)</li>
<li>如果 v==1，通过测试，返回</li>
<li>令 i=1</li>
<li>如果 v==n-1，通过测试，返回</li>
<li>如果 i==j，非素数，结束</li>
<li>\(v=v^2 mod\ n \)，\(i=i+1\)</li>
<li>循环到 5</li>
</ol>

<pre><code class="language-c++">bool Miller_Rabin(int n)
{
    int m = n - 1;
    int i, j, v, b;
    j = 0;
    while((m&amp;1) == 0)
    {
        m &gt;&gt;= 1;
        j ++;
    }

    v = 1;
    b = rand()%(n-3) + 2;
    while(m!=0)
    {
        if(m&amp;1)
            v = (v*b)%n;
        b = b*b%n;
        m &gt;&gt;= 1;
    }

    if(v == 1)
        return true;

    for(i = 1;;i++)
    {
        if(v == n-1)
            return true;
        if(i == j)
            return false;
        v = (v*v)%n;
    }

    return false;
}

bool repeat_M_R(int n)//素性测试
{
    for(int i = 1; i&lt;=3;i++)
    {
        if(Miller_Rabin(n) == false)
            return false;
    }
    return true;
}
</code></pre>

</main>

  <footer>
  <script>
(function() {
    var i, text, code, codes = document.getElementsByTagName('code');
    for (i = 0; i < codes.length;) {
      code = codes[i];
      if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
        text = code.textContent;
        if (/^\$[^$]/.test(text) && /[^$]\$$/.test(text)) {
          text = text.replace(/^\$/, '\\(').replace(/\$$/, '\\)');
          code.textContent = text;
        }
        if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
            /^\$(.|\s)+\$$/.test(text) ||
            /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
          code.outerHTML = code.innerHTML;  
          continue;
        }
      }
      i++;
    }
  })();  
</script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/go.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>
  
  <hr/>
  &copy; <a href="mailto:sakeven.jiang@gmail.com">Sakven Jiang</a> 2017 | <a href="https://github.com/sakeven">GitHub</a>
  
  </footer>
  </body>
</html>

